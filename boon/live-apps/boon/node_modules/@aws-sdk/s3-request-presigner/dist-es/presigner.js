import { __assign, __rest } from "tslib";
import { SignatureV4MultiRegion } from "@aws-sdk/signature-v4-multi-region";
import { SHA256_HEADER, UNSIGNED_PAYLOAD } from "./constants";
var S3RequestPresigner = (function () {
    function S3RequestPresigner(options) {
        var resolvedOptions = __assign({ service: options.signingName || options.service || "s3", uriEscapePath: options.uriEscapePath || false, applyChecksum: options.applyChecksum || false }, options);
        this.signer = new SignatureV4MultiRegion(resolvedOptions);
    }
    S3RequestPresigner.prototype.presign = function (requestToSign, _a) {
        if (_a === void 0) { _a = {}; }
        var _b = _a.unsignableHeaders, unsignableHeaders = _b === void 0 ? new Set() : _b, _c = _a.unhoistableHeaders, unhoistableHeaders = _c === void 0 ? new Set() : _c, options = __rest(_a, ["unsignableHeaders", "unhoistableHeaders"]);
        unsignableHeaders.add("content-type");
        Object.keys(requestToSign.headers)
            .map(function (header) { return header.toLowerCase(); })
            .filter(function (header) { return header.startsWith("x-amz-server-side-encryption"); })
            .forEach(function (header) {
            unhoistableHeaders.add(header);
        });
        requestToSign.headers[SHA256_HEADER] = UNSIGNED_PAYLOAD;
        var currentHostHeader = requestToSign.headers.host;
        var port = requestToSign.port;
        var expectedHostHeader = "".concat(requestToSign.hostname).concat(requestToSign.port != null ? ":" + port : "");
        if (!currentHostHeader || (currentHostHeader === requestToSign.hostname && requestToSign.port != null)) {
            requestToSign.headers.host = expectedHostHeader;
        }
        return this.signer.presign(requestToSign, __assign({ expiresIn: 900, unsignableHeaders: unsignableHeaders, unhoistableHeaders: unhoistableHeaders }, options));
    };
    return S3RequestPresigner;
}());
export { S3RequestPresigner };
